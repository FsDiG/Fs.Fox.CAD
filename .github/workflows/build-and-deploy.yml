name: 构建与部署 IFoxCAD (Build and Deploy IFoxCAD)

on:
  push: # 监听所有分支的推送，以便作业条件可以检查 [build] 标签
    branches:
      - '**' # '**' 代表匹配所有分支
  pull_request:
    branches:
      - main # 只监听目标为 main 分支的 pull request 事件
  # 可以选择性地添加 workflow_dispatch 以支持手动触发
  workflow_dispatch:
    inputs:
      branch:
        description: '要运行脚本的源代码分支'
        required: true
        default: 'main'
      deploy: # 新增：用于手动触发时决定是否部署
        description: '是否要将编译成果发布到Build仓库'
        required: false
        type: boolean
        default: false

jobs:
  build-and-deploy:
    runs-on: self-hosted # 指定在自托管的 runner 上运行
    # 条件执行：控制此 job 何时运行
    # 1. 推送到 main 分支时
    # 2. 创建到 main 分支的 Pull Request 时
    # 3. 推送到任何分支且提交信息包含 [build] 关键词时
    # 4. 手动触发时
    if: |
      (github.event_name == 'push' && github.ref == 'refs/heads/main') ||
      (github.event_name == 'pull_request' && github.base_ref == 'main') ||
      (github.event_name == 'push' && (contains(github.event.head_commit.message, '[build]') || contains(github.event.head_commit.message, '[deploy]'))) ||
      (github.event_name == 'workflow_dispatch')

    steps:
      # 检查是否需要部署
      - name: Set deployment flag
        id: set-deploy
        run: |
          $should_deploy = $false
          if ('${{ github.event_name }}' -eq 'push' -and '${{ contains(github.event.head_commit.message, "[deploy]") }}' -eq 'true') {
            $should_deploy = $true
          }
          elseif ('${{ github.event_name }}' -eq 'workflow_dispatch' -and '${{ github.event.inputs.deploy }}' -eq 'true') {
            $should_deploy = $true
          }
          echo "deploy=$should_deploy" >> $env:GITHUB_OUTPUT
        shell: powershell

      # 如果需要部署，先检出目标仓库
      - name: Checkout target repository
        if: steps.set-deploy.outputs.deploy == 'true'
        uses: actions/checkout@v4
        with:
          repository: FsDiG/Build # 目标 Build 仓库的名称
          token: ${{ secrets.BUILD_REPO_TOKEN }} # 用于推送到此目标仓库的 PAT
          path: Build # 将目标仓库克隆到此子目录

      - name: Checkout repository
        uses: actions/checkout@v4 # 检出当前 IFoxCAD 仓库的代码
        with:
          # 如果是手动触发 (workflow_dispatch)，则检出 inputs.branch 指定的分支。
          # 对于其他事件 (如 push, pull_request)，则使用事件关联的 github.ref。
          ref: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.branch || github.ref }}
          path: source_code # 将源代码克隆到这个目录

      - name: Setup MSBuild
        uses: microsoft/setup-msbuild@v1.1 # 设置 MSBuild 环境，用于编译 C#/.NET 项目

      - name: Clear Build folders
        run: |
          echo "Preparing Build folders..."
          # Create directory structure if it doesn't exist
          New-Item -ItemType Directory -Force -Path "Build\DiGLib\DiGArchBase\x64_2019_Debug" | Out-Null
          New-Item -ItemType Directory -Force -Path "Build\DiGLib\DiGArchBase\x64_2019_Release" | Out-Null
          
          # If we're deploying, we don't want to delete existing files in the target repo
          if ('${{ steps.set-deploy.outputs.deploy }}' -ne 'true') {
            # Remove all content from these directories (only if not deploying)
            Remove-Item -Path "Build\DiGLib\DiGArchBase\x64_2019_Debug\*" -Force -Recurse -ErrorAction SilentlyContinue
            Remove-Item -Path "Build\DiGLib\DiGArchBase\x64_2019_Release\*" -Force -Recurse -ErrorAction SilentlyContinue
          }
          
          echo "Build folders prepared."
        shell: powershell

      - name: Restore NuGet packages
        run: |
          echo "Restoring NuGet packages..."         
          cd source_code
          msbuild src/IFoxCAD.AutoCad/Fs.Fox.AutoCad.csproj /t:Restore
          echo "NuGet packages restored."

      # --- 开始项目编译 --- 
      # 注意：编译顺序为先 Debug 后 Release
      # 编译 IFoxCAD.sln 中的 Fs.Fox.AutoCad.csproj 项目

      - name: Build project Fs.Fox.AutoCad (Debug)
        run: |
          echo "Building Fs.Fox.AutoCad project (Debug)..."
          cd source_code
          msbuild src/IFoxCAD.AutoCad/Fs.Fox.AutoCad.csproj /p:Configuration=Debug /p:Platform="Any CPU" /p:ContinuousIntegrationBuild=true /p:OutputPath="..\Build\DiGLib\DiGArchBase\x64_2019_Debug" /verbosity:minimal
          echo "Fs.Fox.AutoCad project (Debug) built."

      - name: Build project Fs.Fox.AutoCad (Release)
        run: |
          echo "Building Fs.Fox.AutoCad project (Release)..."
          cd source_code
          msbuild src/IFoxCAD.AutoCad/Fs.Fox.AutoCad.csproj /p:Configuration=Release /p:Platform="Any CPU" /p:ContinuousIntegrationBuild=true /p:OutputPath="..\Build\DiGLib\DiGArchBase\x64_2019_Release" /verbosity:minimal
          echo "Fs.Fox.AutoCad project (Release) built."

      # --- 结束项目编译 --- 

      # --- 开始部署到 Build Repo (根据新的条件执行) --- 

      - name: Commit and push to Build repository
        # 条件：与 Checkout target repository 步骤的条件一致
        if: steps.set-deploy.outputs.deploy == 'true'
        env: # 将原始提交消息作为环境变量传递，以帮助解决多字节字符编码问题
          ORIGINAL_COMMIT_MESSAGE: ${{ github.event.head_commit.message }}
        run: |
          cd Build # 进入 Build Repo 的本地克隆目录
          
          # 针对 Build Repo 的本地克隆明确设置 Git 提交编码为 UTF-8
          # 这有助于确保提交对象中的消息元数据是 UTF-8
          git config i18n.commitEncoding UTF-8
          Write-Host "Set git i18n.commitEncoding to UTF-8 for this repository clone."

          # 配置提交者信息
          git config --global user.name "GitHub Action Bot"
          git config --global user.email "actions-bot@github.com"
          
          git add . # 暂存所有更改

          # --- Git 诊断信息 (用于调试文件差异问题) ---
          Write-Host "--- Git Status Short ---"
          git status --short
          Write-Host "--- Git Config core.autocrlf ---"
          git config core.autocrlf # 检查行尾符配置
          Write-Host "--- Git Config core.filemode ---"
          git config core.filemode # 检查文件模式跟踪配置
          Write-Host "--- Git Diff Staged (Raw) ---"
          git diff --staged # 显示暂存文件的具体差异
          Write-Host "--- End of Git Diagnostics ---"
          # --- 结束 Git 诊断信息 ---

          # 检查是否有实际的文件更改需要提交
          git diff --staged --quiet
          if ($LASTEXITCODE -ne 0) { # 如果 $LASTEXITCODE 非0，表示有暂存的更改
            # 从环境变量读取原始提交消息，并构建新的提交消息
            $source_commit_msg_from_env = $env:ORIGINAL_COMMIT_MESSAGE
            $commit_message_content = "Update IFoxCAD build artifacts (SHA: ${{ github.sha }}, Branch: ${{ github.ref_name }})`n`n$source_commit_msg_from_env"
            Write-Host "Commit message content (using env var) will be: $commit_message_content"
            
            # 将构造好的提交消息以 UTF-8 编码写入临时文件
            # 这是解决向 git commit -m 传递多字节字符（如中文）时可能发生的编码问题的关键步骤
            # 注意：Set-Content -Encoding UTF8 在 PowerShell 5.1 中会添加 BOM。
            # 如果之前确认无 BOM 的 UTF-8 (使用 New-Object System.Text.UTF8Encoding($false)) 才解决了 GitHub 界面乱码，请确保恢复该实现。
            $commit_message_file = "commit_message.txt"
            Set-Content -Path $commit_message_file -Value $commit_message_content -Encoding UTF8 -NoNewline -Force
            Write-Host "Commit message written to $commit_message_file with UTF-8 encoding (using Set-Content)."

            git commit -F $commit_message_file # 从文件读取提交消息，以确保编码正确性
            
            Write-Host "--- Verifying committed message in Action log (using git log -1 --pretty=%B) ---"
            git log -1 --pretty=%B # 在 Action 日志中验证已提交的消息编码
            Write-Host "--- End of committed message verification ---"
            
            git push # 推送更改到目标 Build Repo
          } else {
            Write-Host "No changes to commit in target repository."
          }
        shell: powershell # 指定使用 powershell 执行此步骤的 run 命令
      # --- 结束部署到 Build Repo ---

